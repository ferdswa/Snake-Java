package com.snake;
import javafx.animation.AnimationTimer;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.media.Media;
import javafx.scene.media.MediaPlayer;
import javafx.stage.Stage;

import java.io.IOException;
import java.util.ArrayList;

/**
 * Based on MyFrame and Play - Controls the display of levels as well as their component sprites (snake, fruit, walls) and JavaFX controls, handles user input to snake via KeyListeners.
 * @author Maxim Carr - Modified
 */
@SuppressWarnings("CallToPrintStackTrace")
public class LevelController {
    /**
     * Stores current player's score
     */
    public Label scoreLabel;
    /**
     * Stores current High Score, zero if new install or user has just cleared the high score file
     */
    public Label currentHighScoreLabel;
    /**
     * The canvas on which the game's sprites are drawn
     */
    public Canvas levelCanvas;
    /**
     * Determines game length, is assigned the user's set game length setting at level setup when startButton is pressed
     */
    private int gameLength;
    /**
     * GameModel - Handles non-sprite information, stores user settings and scores between levels (see GameModel for more information).
     */
    private GameModel gameModel;
    /**
     * Start Game button
     */
    @FXML
    private Button startButton;
    /**
     * Pause Game button
     */
    @FXML
    private Button pauseButton;
    /**
     * Plays soundtrack, if box was checked in settings or left at default (true).
     */
    private MediaPlayer soundTrackPlayer;
    /** Pause Game mechanic boolean*/
    private boolean paused,justUnPaused;

    /**
     * Returns the application to the main menu and stops music player
     */
    @FXML
    protected void returnButton(){
        try{
            FXMLLoader loadStartScreen=new FXMLLoader(getClass().getResource("startScreenView.fxml"));
            Stage stage=(Stage) scoreLabel.getScene().getWindow();
            if(soundTrackPlayer!=null) {
                soundTrackPlayer.stop();
            }
            Scene scene= new Scene(loadStartScreen.load());
            stage.setTitle("Snake: Main Menu");
            stage.setScene(scene);
        } catch (IOException ioException){
            ioException.printStackTrace();
        }
    }

    /**
     * Controls whether the game display loop is paused or not and allows the game loop to see if the game has just been un-paused via justUnPaused allowing it to move its sprites back to their old positions
     */
    @FXML
    protected void pauseButton(){
        paused = !paused;
        if(!paused){
            justUnPaused=true;
        }
    }

    /**
     * Main game loop - takes keyboard input from user, spawns fastFruit on levels 2 and 3, checks for collisions, draws sprites on levelCanvas, adds scores and switches to higher levels when user crosses their set point threshold
     * @param graphicsContext GraphicsContext for sprite info
     * @param snakeHead Sprite - the head of the snake
     * @param fruit Sprite - first fruit generated by game setup
     * @param walls ArrayList of Sprites - walls for Level 3
     */
    protected void runningDisplayLoop(GraphicsContext graphicsContext, SpriteModel snakeHead, SpriteModel fruit, ArrayList<SpriteModel> walls){
        ArrayList<String> keyboardInput = new ArrayList<>();
        SpriteModel fastFruit = new SpriteModel();
        Scene level = scoreLabel.getScene();
        currentHighScoreLabel.setText("TO BEAT: "+gameModel.getScoresFromFile().getFirst().substring(gameModel.getScoresFromFile().getFirst().indexOf(' ')));
        levelCanvas.requestFocus();
        if(gameModel.getCurrentLevel()!=1){
            fastFruit.spawnFruit(graphicsContext);
            fastFruit.setVel(150,-150);
        }
        level.setOnKeyPressed(event -> {//Adds keyboard input
            String direction = event.getCode().toString();
            if (!keyboardInput.contains(direction))
                keyboardInput.add(direction);
        });
        level.setOnKeyReleased(event -> {//Removes keyboard input, allowing for same input to be given again
            String direction = event.getCode().toString();
            keyboardInput.remove(direction);
        });
        ArrayList<SpriteModel>snakeBody=new ArrayList<>();
        IntStorage score = new IntStorage(0);
        if(gameModel.getCurrentLevel()!=1) {
            score.storedInt= gameModel.getCurrentScore();
        }
        int cLevel = gameModel.getCurrentLevel();
        IntStorage tempScore = new IntStorage(0);
        LongStorage prevTime = new LongStorage(System.nanoTime());//wrote new long storage class as Long is apparently deprecated and variable has to be final or semi final to work in handle()
        new AnimationTimer(){
            /**
             * Draws sprites repeatedly causing an animation effect
             * @param currentTime long - the current time in nanoseconds
             */
            public void handle(long currentTime){
                if(!paused){
                    levelCanvas.requestFocus();
                    double elapsed = (currentTime-prevTime.storedLong)/1000000000.0;
                    int intermediateScore;
                    prevTime.storedLong=currentTime;

                    //Determine direction of snake head, now prevents about-turn
                    for (String direction : keyboardInput) {
                        switch (direction) {
                            case "LEFT":
                                if(snakeHead.getCurrentDegree()!=90) {
                                    snakeHead.setVel((cLevel * -150), 0);
                                    snakeHead.rotateByDegree(-90);
                                }
                                break;
                            case "RIGHT":
                                if(snakeHead.getCurrentDegree()!=-90) {
                                    snakeHead.setVel((cLevel * 150), 0);
                                    snakeHead.rotateByDegree(90);
                                }
                                break;
                            case "UP":
                                if(snakeHead.getCurrentDegree()!=180) {
                                    snakeHead.setVel(0, (-150 * cLevel));
                                    snakeHead.rotateByDegree(0);
                                }
                                break;
                            case "DOWN":
                                if(snakeHead.getCurrentDegree()!=0) {
                                    snakeHead.setVel(0, (150 * cLevel));
                                    snakeHead.rotateByDegree(180);
                                }
                                break;
                        }
                    }
                    snakeHead.updatePosition(elapsed);//move
                    fastFruit.updatePosition(elapsed);//move fruit
                    for(SpriteModel bodyPart : snakeBody){
                        bodyPart.follow(cLevel);
                        switch (bodyPart.getCurrentDegree()){
                            case 0:
                                bodyPart.setVel(0, (-150*cLevel));
                                break;
                            case 90:
                                bodyPart.setVel((cLevel*150), 0);
                                break;
                            case 180:
                                bodyPart.setVel(0, (150*cLevel));
                                break;
                            case -90:
                                bodyPart.setVel((-150*cLevel),0);
                                break;
                        }
                        bodyPart.updatePosition(elapsed);
                    }
                    if(justUnPaused){//Unpause logic
                        snakeHead.setPosition(snakeHead.getStoredX(), snakeHead.getStoredY());
                        snakeHead.setVel((int)snakeHead.getStoredVX(), (int)snakeHead.getStoredVY());
                        snakeHead.setCurrentDegree(snakeHead.getStoredDir());
                        for(SpriteModel bodyPart:snakeBody){
                            bodyPart.setPosition(bodyPart.getStoredX(),bodyPart.getStoredY());
                            bodyPart.setVel((int)bodyPart.getStoredVX(),(int)bodyPart.getStoredVY());
                            bodyPart.setCurrentDegree(bodyPart.getStoredDir());
                        }
                        if(gameModel.getCurrentLevel()!=1){
                            fastFruit.setPosition(fastFruit.getStoredX(), fastFruit.getStoredY());
                            fastFruit.setVel((int)fastFruit.getStoredVX(),(int)fastFruit.getStoredVY());
                            fastFruit.setCurrentDegree(fastFruit.getStoredDir());
                        }
                        if(gameModel.getSoundFlag()) {
                            soundTrackPlayer.play();
                        }
                        justUnPaused=false;
                    }
                    //Collision between fast fruit & wall
                    if(gameModel.getCurrentLevel()!=1){
                        if(fastFruit.getPosX()>=800){
                            fastFruit.setVel(fastFruit.getVelX()-300, fastFruit.getVelY());
                            fastFruit.setPosition(795, fastFruit.getPosY());
                        }
                        if(fastFruit.getPosX()<=0){
                            fastFruit.setVel(fastFruit.getVelX()+300, fastFruit.getVelY());
                            fastFruit.setPosition(5, fastFruit.getPosY());
                        }
                        if(fastFruit.getPosY()>=552){
                            fastFruit.setVel(fastFruit.getVelX(), fastFruit.getVelY()-300);
                            fastFruit.setPosition(fastFruit.getPosX(), 548);
                        }
                        if(fastFruit.getPosY()<=0){
                            fastFruit.setVel(fastFruit.getVelX(), fastFruit.getVelY()+300);
                            fastFruit.setPosition(fastFruit.getPosX(), 5);
                        }
                        fastFruit.updatePosition(elapsed);
                    }
                    //Collision between snake head and fast fruit
                    if(snakeHead.intersects(fastFruit)){
                        fastFruit.spawnFruit(graphicsContext);
                        intermediateScore = tempScore.storedInt+1;
                        tempScore.storedInt=intermediateScore;
                        score.storedInt = score.storedInt+3;
                        eatFruit(tempScore.storedInt, snakeHead, snakeBody);
                    }
                    //Collision between snake head and fruit object
                    if(snakeHead.intersects(fruit)) {//respawns fruit
                        fruit.spawnFruit(graphicsContext);
                        intermediateScore = tempScore.storedInt+1;
                        tempScore.storedInt=intermediateScore;
                        score.storedInt = score.storedInt+1;
                        eatFruit(tempScore.storedInt, snakeHead, snakeBody);
                    }
                    //Collision between snake head and tail
                    for(SpriteModel tail:snakeBody){
                        if(tail.intersects(snakeHead)&&snakeBody.indexOf(tail)>2){
                            gameModel.setEndGameScore(score.storedInt);
                            gameModel.setWonFlag(false);
                            gameOver();
                            stop();
                        }
                    }
                    //Collision between snake head and side of screen
                    if((snakeHead.getPosX()>=800)||(snakeHead.getPosY()>=552)||(snakeHead.getPosX()<=0)||(snakeHead.getPosY()<=0)) {
                        gameModel.setEndGameScore(score.storedInt);
                        gameModel.setWonFlag(false);
                        gameOver();
                        stop();
                    }
                    //Collision between snake head and wall sprite
                    if(cLevel==3){
                        for(SpriteModel wall:walls){
                            if(snakeHead.intersects(wall)){
                                gameModel.setEndGameScore(score.storedInt);
                                gameModel.setWonFlag(false);
                                gameOver();
                                stop();
                            }
                        }
                    }
                    if(score.storedInt>(gameModel.getCurrentLevel()*gameLength+((cLevel-1)*gameLength))){
                        gameModel.setCurrentScore(score.storedInt);
                        nextLevel();
                    }
                    graphicsContext.clearRect(0,0, levelCanvas.getWidth(), levelCanvas.getHeight());
                    snakeHead.render(graphicsContext);
                    snakeHead.setStored(snakeHead.getPosX(),snakeHead.getPosY(),snakeHead.getVelX(), snakeHead.getVelY(), snakeHead.getCurrentDegree());
                    for(SpriteModel renderBody:snakeBody){
                        renderBody.render(graphicsContext);
                        renderBody.setStored(renderBody.getPosX(),renderBody.getPosY(),renderBody.getVelX(),renderBody.getVelY(),renderBody.getCurrentDegree());
                    }
                    if(cLevel==3){
                        for(SpriteModel wall:walls){
                            wall.render(graphicsContext);
                        }
                    }
                    scoreLabel.setText(String.format("SCORE: %d",score.storedInt));
                    fruit.render(graphicsContext);
                    if(gameModel.getCurrentLevel()!=1){
                        fastFruit.render(graphicsContext);
                        fastFruit.setStored(fastFruit.getPosX(),fastFruit.getPosY(), fastFruit.getVelX(), fastFruit.getVelY(), fastFruit.getCurrentDegree());
                    }
                }
                else{
                    soundTrackPlayer.pause();
                }
            }
        }.start();
    }

    /**
     * Adds a new sprite with the snake-body image to snakeBody direction of which is determined in SpriteModel, increasing the length of snake by 1.
     * @param tempScore integer - current length of snake
     * @param snakeHead Sprite - head of snake
     * @param snakeBody ArrayList of Sprites - the body of the snake
     */
    private void eatFruit(int tempScore, SpriteModel snakeHead, ArrayList<SpriteModel> snakeBody) {//Spawns a new piece of the snake.
        SpriteModel newSnakeBody = new SpriteModel();
        newSnakeBody.setImage("sources/snake-body.png");
        if (tempScore == 1) {
            newSnakeBody.setFollowing(snakeHead);
        } else {
            newSnakeBody.setFollowing(snakeBody.getLast());
        }
        newSnakeBody.segmentSetup();
        snakeBody.add(newSnakeBody);
    }

    /**
     * Sets up game and spawns initial sprites depending on what level the user is currently on.
     */
    @FXML
    protected void startGameButton() {//setup
        Stage stage = (Stage) scoreLabel.getScene().getWindow();
        gameModel = (GameModel) stage.getUserData();
        String froggerPath = String.valueOf(getClass().getResource("sources/frogger.mp3"));
        Media soundtrack = new Media(froggerPath);
        soundTrackPlayer = new MediaPlayer(soundtrack);
        if (gameModel.getSoundFlag()) {
            soundTrackPlayer.play();
            soundTrackPlayer.setCycleCount(MediaPlayer.INDEFINITE);
        }
        if (gameModel.isLong())
            gameLength = 25;
        else if (gameModel.isMed())
            gameLength = 10;
        else if(gameModel.isShort())
            gameLength = 5;
        if(gameModel.isEndless())
            gameLength = Integer.MAX_VALUE;
        if (gameModel.getCurrentLevel() == 1)
            scoreLabel.setText("0");
        else
            scoreLabel.setText(String.format("%d", gameModel.getCurrentScore()));
        paused = false;
        GraphicsContext graphicsContext = levelCanvas.getGraphicsContext2D();
        SpriteModel initialFruit = new SpriteModel();
        initialFruit.spawnFruit(graphicsContext);
        SpriteModel snakeHead = new SpriteModel();
        snakeHead.spawnSnakeHead(graphicsContext);
        snakeHead.setVel(gameModel.getCurrentLevel() * 150, 0);
        ArrayList<SpriteModel> walls = null;
        if (gameModel.getCurrentLevel() == 3) {
            walls = new ArrayList<>();
            for (int i = 0; i < 4; i++) {
                SpriteModel wall = new SpriteModel();
                wall.spawnWall(graphicsContext);
                walls.add(wall);
            }
        }
        pauseButton.setVisible(true);
        startButton.setVisible(false);
        runningDisplayLoop(graphicsContext, snakeHead, initialFruit, walls);
    }

    /**
     * Switches level depending on date sent to GameModel by main display loop when score threshold is reached
     */
    protected void nextLevel(){
        switch(gameModel.getCurrentLevel()){
            case 1:
                gameModel.setCurrentLevel(2);
                loadL2();
                break;
            case 2:
                gameModel.setCurrentLevel(3);
                loadL3();
                break;
            case 3:
                gameModel.setWonFlag(true);
                gameModel.setEndGameScore(gameModel.getCurrentScore());
                gameOver();
                break;
        }
    }

    /**
     * Switches level to level two, colour theme depending on user setting loaded from GameModel
     */
    protected void loadL2(){
        try {
            FXMLLoader levelTwoLoader;
            if (gameModel.getDarkFlag()) {
                levelTwoLoader = new FXMLLoader(getClass().getResource("levelTwoDarkView.fxml"));
            } else {
                levelTwoLoader = new FXMLLoader(getClass().getResource("levelTwoView.fxml"));
            }
            Stage stage = (Stage) scoreLabel.getScene().getWindow();
            Scene scene = new Scene(levelTwoLoader.load());
            soundTrackPlayer.stop();
            if (stage != null) {
                stage.setUserData(gameModel);
                stage.setTitle("Snake: Level Two");
                stage.setScene(scene);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Switches level to level three, colour theme depending on user setting loaded from GameModel
     */
    protected void loadL3(){
        try {
            FXMLLoader levelThreeLoader;
            if (gameModel.getDarkFlag()) {
                levelThreeLoader = new FXMLLoader(getClass().getResource("levelThreeDarkView.fxml"));
            } else {
                levelThreeLoader = new FXMLLoader(getClass().getResource("levelThreeView.fxml"));
            }
            Stage stage = (Stage) scoreLabel.getScene().getWindow();
            Scene scene = new Scene(levelThreeLoader.load());
            soundTrackPlayer.stop();
            if (stage != null) {
                stage.setUserData(gameModel);
                stage.setTitle("Snake: Level Three");
                stage.setScene(scene);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Ends the game, sends score to GameModel, switches to game over screen
     */
    protected void gameOver(){
        try{
            FXMLLoader gameOver=new FXMLLoader(getClass().getResource("gameOverView.fxml"));
            Stage stage=(Stage) scoreLabel.getScene().getWindow();
            Scene scene= new Scene(gameOver.load());
            soundTrackPlayer.stop();
            if(stage!=null) {
                stage.setUserData(gameModel);
                stage.setTitle("Snake: Game Over");
                stage.setScene(scene);
            }
        } catch (IOException ioException){
            ioException.printStackTrace();
        }
    }

    /**
     * Initialises buttons by hiding Pause Game and showing Start Game
     */
    @FXML
    protected void initialize(){
        startButton.setVisible(true);
        pauseButton.setVisible(false);
    }
}
